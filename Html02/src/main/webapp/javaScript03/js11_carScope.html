<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script>
// Test1. Variable 선언
// 1.1) var : 재선언가능, 재할당가능
	var i=100; i='가나다'; i=123.456; 
	var i ='Korea'; 
	document.write("var i => "+i+"<br>");
	
// 1.2) let : 재선언불가능, 재할당가능
	let j =123 ; j='green', j=123.456;
	//let j ='let_Test'; // 파싱단게에서 Error -> Script 전체 실행 안됨 
	//var j = 'var_Test';// 파싱단게에서 Error
	document.write("let j => "+j+"<br>");
	
// 1.3) const : 재선언불가능, 재할당불가능
	const PI =3.141592;
	// const PI ='const_Test'; //파싱단게에서 Error
	// PI=333.45678; // 실행단계에서 Error
	document.write("let PI => "+PI+"<br>");
	


// 1.4) delete   
// => 묵시적 변수, 프로퍼티 , 배열의 원소 를 삭제  
// => var, let, const 로 정의한 변수에는 적용되지 않고,
//     정의 없이 사용한 변수에만 적용됨.
// => 삭제를 하면 true를 반환 , 아니면 false를 반환
// 		존재하지 않는 속성을 delete 하면 delete는 어떠한 작업도 없이 true를 반환 
	document.write(" **delete TEST **<br>");
	delete i; delete j; delete PI; // Error 없고 delete 만 안됨 .
	name='홍길동';
	delete name ;
	document.write("delete Test i,j,PI :"+i+","+j+","+PI+"<br>");
	/* document.write("delete Test name:"+name+"<br>"); 
	Error -> Uncaught ReferenceError: name is not defined
  */
// => 배열 원소 Test 
// => 해당자료가 undefined j
	var arr = ['가','나','다','라'];
	document.write(" **delete Before TEST **<br>");
  	for(var i of arr) {
  		document.write(" "+i);
  	}
  	
	document.write(" delete Before , arr.length =>"+arr.length+"<br>");
  	delete arr[2];
	document.write("<br> **delete After TEST **<br>");
  	for(var i of arr) {
  		document.write(" "+i);
  	}
	document.write(" delete After , arr.length =>"+arr.length+"<br>");
  
// => 객체의 프로퍼티 Test 
	var student= { 
			name: '홍길동',
			score: 100 ,
			study: function(){
			return	"** Test delete Object Method <br>" ;
			}
		}
	delete student.score;	
	delete student.study;
	document.write("* After delete student.score=>"+student.score+"<br>");
	document.write("* After delete studnet.study=>"+student.study+"<br>");
	document.write("** Test delete Object Method End <br>");
	
	
// Test2. Variable 적용범위   
// 2.1) 전역변수 : 현재스크립트내 어디서든 사용가능
	var sum =100; 
	var name ='banana';
	document.write("전역 sum  =>"+sum+"<br>");
	document.write("전역 f(cnt)=>"+f(5)+"<br>");
	//document.write("전역 name=>"+name+"<br>"); // name is not defined
	document.write("전역 test=>"+test+"<br>");
	//=> f(5) 가 일단 호출된 후에는 전역으로 인식 가능함.
	document.write("전역 sum=>"+sum+"<br>");
	 
// 2.2) 지역변수 : 정의된 function 내에서만 사용가능
	function f(cnt){
	var name = '김길동'; // 명시적 선언한 지역변수 
	test ='TESTtest'; // 묵시적 지역변수
	// => 일단 실행되어 값이 할당되면 , 전역으로 사용됨.
	// => 이러한 변수는 전역에서만 사용할것을 권장하고,
	// 	  지역번수는 명시적으로 사용할 것을 권장함. 
	document.write("infunction name=>"+name+"<br>");
	document.write("infunction 전역 window.name=>"+window.name+"<br>");
	document.write("infunction 전역 this.name=>"+this.name+"<br>");
	// 동일한 변수명이 있는 경우 전역 변수에 접근 할때 => this , window
	// => this 또는 window로 접근 (이 외에도 전역객체를 가리키는 식별자는 self, frames, global 등 )
	// 	  이 있으나, ECMA11 (ES11) 에서는 globalThis 로 통일됨 
	document.write("infunction test=>"+test+"<br>");
	document.write("infunction cnt=>"+cnt+"<br>");
	sum =0;
	// 반복자로 정의한 ii 는 function에 종속된 지역변수임 
	for(var ii= 0; ii<cnt ; ii++){
		sum+=1 ;
	}
	document.write("infunction ii=>"+ii+"<br>");
	
	return sum;
}// f 
	// test의 사용범위 test 
	// 일단 실행되어 값이 할당되면, 전역으로 사용됨 (타 function 에서도 접근 가능 )
	testf(); 
	function testf() {
	document.write("infunction testf() =>"+test+"<br>");
	}
</script>
</head>
<body>
<pre><h2>
** Variable 선언과 적용범위 ***

1. 선언
1.1) 변수
   => var : 재선언가능, 재할당가능 
   => let : 재선언불가능, 재할당가능 
1.2) 상수
   => const : 재선언불가능, 재할당불가능      
1.3) 묵시적 정의(var,let,const 없이 정의) 
   => 전역변수의 경우
   => 차이점
   	  delete 가 적용됨 (변수와 값이 메모리에서 삭제됨)
      명시적 선언시에는 delete 가 적용되지않고, 변수와 값이 메모리에 보존됨 
1.4) delete
   => 변수의 정의를 취소함
   => var, let, const 로 정의한 변수에는 적용되지 않고,
      정의 없이 사용한 변수에만 적용됨. 
<!-- ** Object.defineProperty()

=> 객체의 프로퍼티 정의시 delete 로 삭제 가능 여부가 결정됨
   아래 configurable : 삭제가능 true/ 기본값은 false.

=> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

=> 정적 메서드는 객체에 직접 새로운 속성을 정의하거나
   이미 존재하는 속성을 수정한 후, 그 객체를 반환합니다.
=> defineProperty는 Object 인스턴스가 아니라 생성자에서 바로 호출해야 합니다. 

=> 구문
   Object.defineProperty(obj, prop, descriptor)
-> obj : 속성을 정의할 객체.
-> prop : 새로 정의하거나 수정하려는 속성의 이름 또는 Symbol.
-> descriptor : 새로 정의하거나 수정하려는 속성을 기술하는 객체.
-> 반환 값 : 주어진 대상 obj.   

=> 속성 서술자property descriptors는 객체로 나타내며
   데이터 서술자data descriptors와 접근자 서술자accessor descriptors의 두 가지 유형을 갖습니다.
   데이터 서술자는 값을 가지는 속성으로, 덮어쓰거나 쓸 수 없습니다.
   접근자 서술자는 접근자getter-설정자setter 한 쌍을 가지는 속성입니다.
   서술자는 두 유형 중 하나여야 하며, 동시에 두 유형일 수는 없습니다.
   데이터 서술자와 접근자 서술자 모두 객체이며 다음과 같은 키를 공유합니다.
   
-> configurable
   이 속성의 값을 변경할 수 있고, 대상 객체에서 삭제할 수도 있다면 true.
   기본값은 false.
-> enumerable
   이 속성이 대상 객체의 속성 열거 시 노출된다면 true.
   기본값은 false.
   데이터 서술자는 다음 키를 선택사항으로 가집니다.

-> value
   속성에 연관된 값. 아무 유효한 JavaScript 값(숫자, 객체, 함수 등)이나 가능합니다.
   기본값은 undefined
-> writable
   할당 연산자 (en-US)로 속성의 값을 바꿀 수 있다면 true.
   기본값은 false.   
   
-----------------------------------------------------

** 엄격 모드(strict mode)
=> ES5(2009)부터 생긴 것인데, 
   자바스크립트 내에서 아래 버전의 호환성은 가져가면서도 
   새롭게 정의된 스펙을 따르게 하기 위해서 생겼습니다.

=> 엄격모드를 가동하려면 javascript 소스 맨 위에 "use strict"라는 코드를 작성하면 됩니다.

=> 엄격모드를 가동하면,
   기존에는 조용히 무시되던 에러들을 throwing합니다.
   JavaScript 엔진의 최적화 작업을 어렵게 만드는 실수들을 바로잡습니다.
   가끔씩 엄격 모드의 코드는 비-엄격 모드의 동일한 코드보다 더 빨리 작동하도록 만들어집니다.
   엄격 모드는 ECMAScript의 차기 버전들에서 정의 될 문법을 금지합니다.
=> https://ko.javascript.info/strict-mode   
   
 -->
</h2></pre>
 

</body>
</html>